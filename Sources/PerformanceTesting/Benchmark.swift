//
//  Benchmark.swift
//  PerformanceTesting
//
//  Created by James Bean on 8/11/17.
//

import Foundation

public struct Benchmark {

    // MARK: - Type Methods

    /// - Returns: A `Benchmark` for an `operation` over a given size. This operation is
    /// measured `trialCount` times at each of the sizes in `testPoints`.
    public static func algorithm(
        trialCount: Int = 10,
        testPoints: [Int] = Scale.medium,
        measuring operation: @escaping (Int) -> Void
    ) -> Benchmark
    {
        return .nonMutating(
            trialCount: trialCount,
            testPoints: testPoints,
            setup: { $0 },
            measuring: operation
        )
    }

    /// - Returns: A `Benchmark` for an `operation` which mutates a `Subject` generated by `setup`.
    /// This operation is measured `trialCount` times at each of the sizes in `testPoints`.
    public static func mutating <Subject> (
        trialCount: Int = 10,
        testPoints: [Int] = Scale.medium,
        setup: @escaping (Int) -> Subject,
        measuring operation: @escaping (inout Subject) -> Void
    ) -> Benchmark
    {
        return Benchmark(
            testPoints: testPoints.map { size in
                return TestPoint(
                    size: size,
                    trials: (0..<trialCount).map { _ in
                        var subject = setup(size)
                        return measure { operation(&subject) }
                    }
                )
            }
        )
    }

    /// - Returns: A `Benchmark` for an `operation` which acts on a `Subject` generated by `setup`.
    /// This operation will be measured `trialCount` times at each of the sizes in `testPoints`.
    public static func nonMutating <Subject> (
        trialCount: Int = 10,
        testPoints: [Int] = Scale.medium,
        setup: @escaping (Int) -> Subject,
        measuring operation: @escaping (Subject) -> Void
    ) -> Benchmark
    {
        return Benchmark(
            testPoints: testPoints.map { size in
                let subject = setup(size)
                return TestPoint(
                    size: size,
                    trials: (0..<trialCount).map { _ in measure { operation(subject) } }
                )
            }
        )
    }

    // MARK: - Instance Properties

    /// - Returns: The average measure time to perform an operation, indexed by the size of the
    /// domain.
    var data: [(x: Double, y: Double)] {
        return testPoints.map { (x: Double($0.size), y: $0.trials.average) }
    }

    let testPoints: [TestPoint]

    // MARK: - Initializers

    init(testPoints: [TestPoint]) {
        self.testPoints = testPoints
    }

    /// - Returns: `true` if the computed average time complexity of this `Benchmark` is in the
    /// given `complexity` class on the scale of inputs.
    public func performance(is complexity: Complexity) -> Bool {
        switch complexity {
        case .constant:
            let results = linearRegression(data)
            let tolerance = 0.1
            return (
                approximatelyEqual(results.slope, 0, epsilon: tolerance) || results.correlation < 0.9
            )
        default:
            let mappedData = data.mappedForLinearFit(complexity: complexity)
            let results = linearRegression(mappedData)
            let minimumCorrelation = 0.9
            return results.correlation >= minimumCorrelation
        }
    }
}

/// - Returns: The amount of time that it takes to perform the given `operation`.
private func measure (operation: () -> Void) -> Double {
    let start = CFAbsoluteTimeGetCurrent()
    operation()
    let finish = CFAbsoluteTimeGetCurrent()
    return finish - start
}
