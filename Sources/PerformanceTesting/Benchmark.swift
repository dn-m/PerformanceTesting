//
//  Benchmark.swift
//  PerformanceTesting
//
//  Created by James Bean on 8/11/17.
//

import Foundation

/// Collection of `TestPoint` values.
public struct Benchmark {

    // MARK: - Type Methods

    /// - Returns: A `Benchmark` for an `operation` over a given size. This operation is
    /// measured `trialCount` times at each of the sizes in `testPoints`.
    public static func algorithm(
        trialCount: Int = 10,
        testPoints: [Int] = Scale.medium,
        measuring operation: @escaping (Int) -> Void
    ) -> Benchmark
    {
        return .nonMutating(
            trialCount: trialCount,
            testPoints: testPoints,
            setup: { $0 },
            measuring: operation
        )
    }

    /// - Returns: A `Benchmark` for an `operation` which mutates a `Subject` generated by `setup`.
    /// This operation is measured `trialCount` times at each of the sizes in `testPoints`.
    public static func mutating <Subject> (
        trialCount: Int = 10,
        testPoints: [Int] = Scale.medium,
        setup: @escaping (Int) -> Subject,
        measuring operation: @escaping (inout Subject) -> Void
    ) -> Benchmark
    {
        return Benchmark(
            testPoints: testPoints.map { size in
                return TestPoint(
                    size: size,
                    trials: (0..<trialCount).map { _ in
                        var subject = setup(size)
                        return measure { operation(&subject) }
                    }
                )
            }
        )
    }

    /// - Returns: A `Benchmark` for an `operation` which acts on a `Subject` generated by `setup`.
    /// This operation will be measured `trialCount` times at each of the sizes in `testPoints`.
    public static func nonMutating <Subject> (
        trialCount: Int = 10,
        testPoints: [Int] = Scale.medium,
        setup: @escaping (Int) -> Subject,
        measuring operation: @escaping (Subject) -> Void
    ) -> Benchmark
    {
        return Benchmark(
            testPoints: testPoints.map { size in
                let subject = setup(size)
                return TestPoint(
                    size: size,
                    trials: (0..<trialCount).map { _ in measure { operation(subject) } }
                )
            }
        )
    }

    // MARK: - Instance Properties

    var data: DataSet {
        return DataSet(testPoints.map { (Double($0.size), $0.average) })
    }

    let testPoints: [TestPoint]

    // MARK: - Initializers

    init(testPoints: [TestPoint]) {
        self.testPoints = testPoints
    }

    /// - Returns: `true` if the computed average time complexity of this `Benchmark` is in the
    /// given `complexity` class on the scale of inputs.
    public func performance(
        is complexity: Complexity,
        tolerance: Double = 0.05,
        minimumCorrelation: Double = 0.9
    ) -> Bool
    {
        return data.curve(
            is: complexity,
            tolerance: tolerance,
            minimumCorrelation: minimumCorrelation
        )
    }
}

extension Benchmark: CustomStringConvertible {
    public var description: String {
        return testPoints.map { "\($0)" }.joined(separator: "\n")
    }
}

/// - Returns: The amount of time that it takes to perform the given `operation`.
private func measure (operation: () -> Void) -> Double {
    let start = CFAbsoluteTimeGetCurrent()
    operation()
    let finish = CFAbsoluteTimeGetCurrent()
    return finish - start
}

extension Array where Element == Double {

    public var sum: Double {
        return reduce(0,+)
    }

    public var average: Double {
        assert(count > 0)
        return sum / Double(count)
    }
}
